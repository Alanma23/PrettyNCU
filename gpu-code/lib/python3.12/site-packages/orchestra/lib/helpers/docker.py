"""Docker helper functions for Orchestra."""

import json
import os
import subprocess
import tempfile
from pathlib import Path
from typing import List, Optional

from orchestra.lib.logger import get_logger

logger = get_logger(__name__)


def get_docker_container_name(session_id: str) -> str:
    """Get the Docker container name for a session."""
    return f"orchestra-{session_id}"


def ensure_docker_image() -> bool:
    """Ensure the orchestra Docker image exists, building it if necessary."""
    try:
        # Check if image exists
        result = subprocess.run(
            ["docker", "images", "-q", "orchestra-image"],
            capture_output=True,
            text=True,
        )

        if result.stdout.strip():
            logger.info("Docker image 'orchestra-image' already exists")
            return True

        logger.info("Building orchestra-image...")

        # Get the Dockerfile from the package
        import orchestra
        package_dir = Path(orchestra.__file__).parent
        dockerfile_path = package_dir / "Dockerfile"

        if not dockerfile_path.exists():
            logger.error(f"Dockerfile not found at {dockerfile_path}")
            return False

        # Build the image with current user's UID/GID
        uid = os.getuid()
        gid = os.getgid()

        # Create a temporary directory for build context
        with tempfile.TemporaryDirectory() as tmpdir:
            # Copy Dockerfile
            import shutil
            shutil.copy(dockerfile_path, tmpdir)

            # Copy orchestra-hook-forward.sh if it exists
            hook_script = package_dir / "runners" / "orchestra-hook-forward.sh"
            if hook_script.exists():
                runners_dir = Path(tmpdir) / "runners"
                runners_dir.mkdir(exist_ok=True)
                shutil.copy(hook_script, runners_dir)

            # Build image
            result = subprocess.run(
                [
                    "docker",
                    "build",
                    "-t",
                    "orchestra-image",
                    "--build-arg",
                    f"USER_ID={uid}",
                    "--build-arg",
                    f"GROUP_ID={gid}",
                    tmpdir,
                ],
                capture_output=True,
                text=True,
            )

            if result.returncode != 0:
                logger.error(f"Failed to build Docker image: {result.stderr}")
                return False

            logger.info("Successfully built orchestra-image")
            return True

    except Exception as e:
        logger.error(f"Error ensuring Docker image: {e}")
        return False


def ensure_shared_claude_config(shared_claude_dir: Path, shared_claude_json: Path, mcp_port: int = 8765) -> bool:
    """Ensure shared Claude configuration exists."""
    try:
        # Create shared Claude directory
        shared_claude_dir.mkdir(parents=True, exist_ok=True)

        # Check if host has Claude config
        host_claude_json = Path.home() / ".claude.json"
        if host_claude_json.exists():
            # Copy host config to shared location
            import shutil
            shutil.copy(host_claude_json, shared_claude_json)
            logger.info(f"Copied Claude config from {host_claude_json} to {shared_claude_json}")

        # Create MCP configuration
        mcp_url = f"http://host.docker.internal:{mcp_port}/mcp"
        mcp_config = {
            "mcpServers": {
                "orchestra-mcp": {
                    "url": mcp_url,
                    "type": "http"
                }
            }
        }

        mcp_config_path = shared_claude_dir / ".mcp.json"
        with open(mcp_config_path, "w") as f:
            json.dump(mcp_config, f, indent=2)

        logger.info(f"Created MCP config at {mcp_config_path}")

        # Create settings.json with pre-approved permissions
        settings_config = {
            "permissions": {
                "allow": [
                    "mcp__orchestra-mcp__spawn_subagent",
                    "mcp__orchestra-mcp__send_message_to_session"
                ],
                "allowPathRegex": ["^~/.orchestra/.*"]
            }
        }

        settings_path = shared_claude_dir / "settings.json"
        with open(settings_path, "w") as f:
            json.dump(settings_config, f, indent=2)

        logger.info(f"Created settings.json at {settings_path}")
        return True

    except Exception as e:
        logger.error(f"Error ensuring shared Claude config: {e}")
        return False


def start_docker_container(
    container_name: str,
    work_path: str,
    mcp_port: int = 8765,
    paired: bool = False,
) -> bool:
    """Start a Docker container for a session."""
    try:
        # Check if container already exists
        check_result = subprocess.run(
            ["docker", "ps", "-a", "-q", "-f", f"name=^{container_name}$"],
            capture_output=True,
            text=True,
        )

        if check_result.stdout.strip():
            # Container exists, check if it's running
            is_running = subprocess.run(
                ["docker", "ps", "-q", "-f", f"name=^{container_name}$"],
                capture_output=True,
                text=True,
            )

            if is_running.stdout.strip():
                logger.info(f"Container {container_name} is already running")
                return True
            else:
                # Start existing container
                logger.info(f"Starting existing container {container_name}")
                result = subprocess.run(
                    ["docker", "start", container_name],
                    capture_output=True,
                    text=True,
                )
                return result.returncode == 0

        # Create new container
        logger.info(f"Creating new container {container_name}")

        # Prepare Docker run command
        shared_claude_dir = Path.home() / ".orchestra" / "shared-claude"

        cmd = [
            "docker",
            "run",
            "-d",
            "--name",
            container_name,
            "-v",
            f"{work_path}:/workspace",
            "-v",
            f"{shared_claude_dir}:/home/executor/.claude",
            "--add-host",
            "host.docker.internal:host-gateway",
            "-e",
            f"MCP_PORT={mcp_port}",
        ]

        # Add API key if present
        api_key = os.environ.get("ANTHROPIC_API_KEY")
        if api_key:
            cmd.extend(["-e", f"ANTHROPIC_API_KEY={api_key}"])

        # Run container with tail -f /dev/null to keep it running
        cmd.extend(["orchestra-image", "tail", "-f", "/dev/null"])

        result = subprocess.run(cmd, capture_output=True, text=True)

        if result.returncode != 0:
            logger.error(f"Failed to start container: {result.stderr}")
            return False

        logger.info(f"Successfully started container {container_name}")
        return True

    except Exception as e:
        logger.error(f"Error starting Docker container: {e}")
        return False


def stop_docker_container(container_name: str) -> bool:
    """Stop and remove a Docker container."""
    try:
        # Stop container
        subprocess.run(
            ["docker", "stop", container_name],
            capture_output=True,
            text=True,
        )

        # Remove container
        result = subprocess.run(
            ["docker", "rm", container_name],
            capture_output=True,
            text=True,
        )

        logger.info(f"Stopped and removed container {container_name}")
        return result.returncode == 0

    except Exception as e:
        logger.error(f"Error stopping Docker container: {e}")
        return False


def docker_exec(container_name: str, cmd: List[str]) -> subprocess.CompletedProcess:
    """Execute a command inside a Docker container."""
    full_cmd = ["docker", "exec", container_name] + cmd
    return subprocess.run(
        full_cmd,
        capture_output=True,
        text=True,
    )
